#Источник: https://pythonstart.ru/string/strokoviy-metod-format-python

'''Метод string format() в Python
форматирует данную строку в более удобный вывод в Python.
Синтаксис метода:'''
#  template.format(p0, p1, ..., k0=v0, k1=v1, ...)

'''Здесь p0, p1, … ‒ позиционные аргументы, а k0, k1, … ‒ аргументы ключевого слова со значениями v0, v1, … соответственно.
И шаблон ‒ это смесь кодов формата с заполнителями для аргументов.
Параметры Команда принимает любое количество параметров. Но, делится на два типа параметров: 
    Позиционные параметры ‒ список параметров, к которым можно получить доступ, указав индекс параметра
 в фигурных скобках {index}.
    Параметры ключевого слова ‒ список параметров типа ключ = значение, к которым можно получить доступ с помощью 
ключа параметра в фигурных скобках {ключ}. 

Возвращаемое значение Метод в Python возвращает отформатированную строку. 
  Как работает string format()? 
Функция считывает тип переданных ей аргументов и форматирует ее в соответствии с кодами формата, определенными в строке.
Для позиционных аргументов Здесь аргумент 0 ‒ это строка «Адам», а аргумент 1 ‒ плавающее число 230.2346. 
Примечание: В Python список аргументов начинается с 0. 
    Строка «Здравствуйте, {0}, ваш баланс составляет {1: 9.3f}» ‒ это строка шаблона. 
Он содержит коды формата для форматирования. 
Фигурные скобки ‒ это просто заполнители для размещения аргументов. 
В приведенном выше примере {0} является заполнителем для «Адама», а {1: 9.3f} ‒ заполнителем для 230.2346 . 
Поскольку строка шаблона ссылается на аргументы format() как {0} и {1}, аргументы являются позиционными. 
На них обоих также можно ссылаться без чисел, поскольку {} и Python внутренне преобразует их в числа.

Внутри: 
Поскольку «Адам» является 0-м аргументом, он помещается вместо {0}. 
Поскольку {0} не содержит никаких других кодов формата, он не выполняет никаких других операций. 
Однако это не относится к 1-му аргументу 230.2346. Здесь {1: 9.3f} помещает 230.2346 на его место 
и выполняет операцию 9.3f. 
f указывает формат работы с числом с плавающей запятой. 
Если не правильно указать, выдаст ошибку. 
Часть перед «.» (9) определяет минимальную ширину/заполнение, которое может принимать число (230.2346). 
В этом случае 230.2346 отводится минимум 9 мест, включая «.». Если параметр выравнивания не указан, он выравнивается 
по правому краю оставшихся пробелов. 
(Для строк он выравнивается по левому краю). 
Часть после «.» (3) обрезает десятичную часть (2346) до заданного числа. 
В этом случае 2346 усекается после 3 разрядов. Остальные числа (46) округляем, получая 235. 
Для аргументов ключевого слова Мы использовали тот же пример выше, 
чтобы показать разницу между ключевыми и позиционными аргументами. 
Здесь вместо параметров мы использовали пару «ключ-значение» для параметров. 
А именно name = «Adam» и blc = 230.2346. Поскольку на эти параметры ссылаются их ключи, 
как {name} и {blc: 9.3f}, они известны как ключевое слово или именованные аргументы. '''


'''Внутри: 
Заполнитель {имя} заменяется значением имени ‒ «Адам». Поскольку он не содержит никаких других кодов формата, 
помещается «Адам». Для аргумента blc = 230.2346 заполнитель {blc: 9.3f} заменяется значением 230.2346. 
Но перед его заменой, как и в предыдущем примере, он выполняет над ним операцию 9.3f. Это выводит 230.235.0. 
Десятичная часть обрезается после трех знаков, а оставшиеся цифры округляются. 
Аналогично, общая ширина назначена 9, оставляя два пробела слева.'''
#__________
'''   Базовое форматирование 
Метод позволяет использовать простые заполнители для форматирования. 
    Пример 1: Базовое форматирование для аргументов по умолчанию, позиционных и ключевых слов'''
# default arguments
print("Hello {}, your balance is {}.".format("Adam", 230.2346))

# positional arguments
print("Hello {0}, your balance is {1}.".format("Adam", 230.2346))
# keyword arguments
print("Hello {name}, your balance is {blc}.".format(name="Adam", blc=230.2346))
# mixed arguments
print("Hello {0}, your balance is {blc}.".format("Adam", blc=230.2346))

'''
Примечание: В случае смешанных аргументов аргументы ключевого слова всегда должны следовать за 
позиционными аргументами. 
Форматирование чисел Вы можете форматировать числа, используя описатель формата, указанный ниже: 
    Типы форматирования чисел 
    Тип Пример 
d   -   Десятичное целое число 
c   -   Соответствующий символ Юникода 
b   -   Двоичный формат 
o   -   Восьмеричный формат 
x   -   Шестнадцатеричный формат (нижний регистр) 
X   -   Шестнадцатеричный формат (верхний регистр) 
n   -   То же, что и d. За исключением того, что для разделителя чисел используется текущий языковой стандарт. 
e   -   Экспоненциальная запись. (строчная е) 
E   -   Экспоненциальная запись (прописная E) 
f   -   Отображает номер с фиксированной точкой (по умолчанию: 6) 
F   -   То же, что и f. За исключением того, что отображает inf как INF и nan как NAN. 
g   -   Общий формат. Округляет число до p значащих цифр. (Точность по умолчанию: 6) 
G   -   То же, что и g. За исключением переключения на «E», если число большое. 
%   -   Процент. Умножает на 100 и ставит% в конце.

'''
''' Пример 2: Простое форматирование чисел   '''
# integer arguments
print("The number is:{:d}".format(123))

# float arguments
print("The float number is:{:f}".format(123.4567898))

# octal, binary and hexadecimal format
print("bin: {0:b}, oct: {0:o}, hex: {0:x}".format(12))

'''Пример 3: Форматирование чисел с заполнением для int и float'''
# integer numbers with minimum width
print("{:5d}".format(12))

# width doesn't work for numbers longer than padding
print("{:2d}".format(1234))

# padding for float numbers
print("{:8.3f}".format(12.2346))

# integer numbers with minimum width filled with zeros
print("{:05d}".format(12))

# padding for float numbers filled with zeros
print("{:08.3f}".format(12.2346))

'''Вот: 
в первом операторе {: 5d} принимает целочисленный аргумент и присваивает минимальную ширину 5. 
Поскольку выравнивание не задано, оно выравнивается по правому краю. 
Во втором утверждении вы можете видеть, что ширина (2) меньше числа (1234), поэтому он не занимает места слева, 
но также не усекает число. 
В отличие от целых чисел, числа с плавающей запятой имеют как целую, так и десятичную части. 
И минимальная ширина, определенная для числа, предназначена для обеих частей в целом, включая «.». 
В третьем операторе {: 8.3f} усекает десятичную часть на 3 разряда, округляя последние 2 цифры. 
И число, теперь 12,235, принимает ширину 8 в целом, оставляя 2 места слева. 
Если вы хотите заполнить оставшиеся места нулями, поместите ноль перед описателем формата. 
Он работает как для целых чисел, так и для чисел с плавающей запятой: {: 05d} и {: 08.3f}.
'''
#Пример 4: для чисел со знаком
''' Пример 4: для чисел со знаком   '''
# show the + sign
print("{:+f} {:+f}".format(12.23, -12.23))

# show the - sign only
print("{:-f} {:-f}".format(12.23, -12.23))

# show space for + sign
print("{: f} {: f}".format(12.23, -12.23))

'''Форматирование чисел с выравниванием 
Операторы <, ^,> и = используются для выравнивания, когда номерам присвоена определенная ширина. 
Форматирование чисел с выравниванием 
Тип Имея в виду 
<   -   Выровнен по левому краю относительно оставшегося пространства 
^   -   Центр выровнен по оставшемуся пространству 
>   -   Выровнен по правому краю по оставшемуся пространству 
=   -   Переводит знак (+) (-) в крайнее левое положение'''
# Пример 5: с выравниванием по левому, правому и центру
''' Пример 5: с выравниванием по левому, правому и центру   '''
# integer numbers with right alignment
print("{:5d}".format(12))

# float numbers with center alignment
print("{:^10.3f}".format(12.2346))

# integer left alignment filled with zeros
print("{:<05d}".format(12))

# float numbers with center alignment
print("{:=8.3f}".format(-12.2346))

'''Примечание: Выравнивание по левому краю, заполненное нулями для целых чисел, может вызвать проблемы, 
как в третьем примере, который возвращает 12000, а не 12. 
Как числа, строка может быть отформатирована аналогичным образом.'''
# Пример 6: Форматирование строки с заполнением и выравниванием
''' Пример 6: Форматирование строки с заполнением и выравниванием   '''
# string padding with left alignment
print("{:5}".format("cat"))

# string padding with right alignment
print("{:>5}".format("cat"))

# string padding with center alignment
print("{:^5}".format("cat"))

# string padding with center alignment
# and '*' padding character
print("{:*^5}".format("cat"))

'''Пример 7: Усечение строк'''
# truncating strings to 3 letters
print("{:.3}".format("caterpillar"))

# truncating strings to 3 letters # and padding
print("{:5.3}".format("caterpillar"))

# truncating strings to 3 letters,
# padding and center alignment
print("{:^5.3}".format("caterpillar"))

'''Форматирование членов класса и словаря Python внутренне использует getattr() для членов класса в форме «.age».
И он использует поиск __getitem __() для членов словаря в форме «[index]».'''
'''Пример 8: Форматирование членов класса'''
# define Person class
class Person:
    age = 23
    name = "Adam"

# format age
print("{p.name}'s age is: {p.age}".format(p=Person()))
'''Здесь объект Person передается как аргумент ключевого слова p . 
Внутри строки шаблона доступ к имени и возрасту человека осуществляется с помощью .name и .age соответственно.'''
#
'''Пример 9: Форматирование элементов словаря'''
# define Person dictionary
person = {'age': 23, 'name': 'Adam'}

# format age
print("{p[name]}'s age is: {p[age]}".format(p=person))

''' Подобно классу, словарь человека передается как аргумент ключевого слова p.
Внутри строки шаблона для доступа к имени и возрасту человека используются [имя] и [возраст] соответственно. 
Есть более простой способ форматирования словарей в Python с помощью str.format (** сопоставление). '''
# define Person dictionary
person = {'age': 23, 'name': 'Adam'}

# format age
print("{name}'s age is: {age}".format(**person))

''' ** ‒ параметр формата (минимальная ширина поля). 

Аргументы, как коды формата Вы также можете динамически передавать коды формата, такие как точность,
 выравнивание, символ заполнения, как позиционные или ключевые аргументы.'''
 #
''' Пример 10: Динамическое форматирование    '''

# dynamic string format template
string = "{:{fill}{align}{width}}"

# passing format codes as arguments
print(string.format('cat', fill='*', align='^', width=5))

# dynamic float format template
num = "{:{align}{width}.{precision}f}"

# passing format codes as arguments
# ????   print(num.format(123.236, align='

'''   Вот: 
В первом примере «кошка» ‒ это позиционный аргумент, который нужно отформатировать. 
Аналогично, fill = ‘*’, align = ‘^’ и width = 5 являются аргументами ключевого слова. 
В строке шаблона эти ключевые аргументы извлекаются не как обычные строки для печати, 
а как фактические коды формата fill, align и width. 
Аргументы заменяют соответствующие именованные заполнители, и строка «cat» форматируется соответствующим образом. 
Аналогичным образом, во втором примере 123.236 является позиционным аргументом, а параметры align,
 width и precision передаются в строку шаблона как коды формата. 
            Дополнительные параметры 
 Команда также поддерживает параметры форматирования для конкретного типа, 
 такие как форматирование даты и времени и комплексное числовое форматирование. 
 Модуль внутренне вызывает __format __() для datetime, а format() обращается к атрибутам комплексного числа.
Вы можете легко переопределить метод __format __() любого объекта для пользовательского форматирования.'''
#
''' Пример 11: Типовое форматирование с помощью format() и переопределения метода __format __() '''

import datetime

# datetime formatting
date = datetime.datetime.now()
print("It's now: {:%Y/%m/%d %H:%M:%S}".format(date))

# complex number formatting
complexNumber = 1+2j
print("Real part: {0.real} and Imaginary part: {0.imag}".format(complexNumber))

# custom __format__() method
class Person:
    def __format__(self, format):
        if(format == 'age'):
            return '23'
        return 'None'
print("Adam's age is: {:age}".format(Person()))
# It's now: 2016/12/02 04:16:28
#  part: 1.0 and Imaginary part: 2.0
# Adam's age is: 23
'''   Вот: 
Для datetime: текущее datetime передается как позиционный аргумент методу format(). 
И, внутренне используя метод __format __(), format() получает доступ к году, месяцу, дню, часу, минутам и секундам. 
Для комплексных чисел: 1 + 2j внутренне преобразуется в объект ComplexNumber. 
Затем, получив доступ к его атрибутам real и imag, число форматируется. 
Переопределение __format __(): как и datetime, вы можете переопределить свой собственный метод __format __() 
для настраиваемого форматирования, который возвращает возраст при доступе как {: age}. 
Вы также можете использовать функции объекта __str __() и __repr __() с сокращенными обозначениями. 
Как и __format __(), вы можете легко переопределить методы объекта __str __() и __repr_(). '''
#
'''Пример 12: __str() __ и __repr() __ сокращенное обозначение !R и !S'''
# __str__() and __repr__() shorthand !r and !s
print("Quotes: {0!r}, Without Quotes: {0!s}".format("cat"))

# __str__() and __repr__() implementation for class
class Person:
    def __str__(self):
        return "STR"
    def __repr__(self):
        return "REPR"

print("repr: {p!r}, str: {p!s}".format(p=Person()))
