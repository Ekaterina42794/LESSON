def func_with_params(a=2, b=3):
    print(a + b)


func_with_params()
func_with_params(0)
func_with_params(1, 7)
print("_")


def func_with_params(a, b=3):
    print(a + b)


# func_with_params()# ошибка  func_with_params() missing 1 required positional argument: 'a'
func_with_params(7, 5)
func_with_params(7)
print("_")


def func_with_params(a, b=6):
    print(a + b)


func_with_params(6)
func_with_params(6,3)

def func_with_params(a, b=6, c=[]):
    c.append(a)
    print(c)

func_with_params(6)
func_with_params(6,3)
func_with_params(6)
func_with_params(6,3)
'''В КОНСОЛИ
[6]
[6, 6]
[6, 6, 6]
[6, 6, 6, 6]
'''

def func_with_params(a, b=6, c=None):
    if c is None:
        c=[]
        c.append(a)
    print(c)

func_with_params(3)
func_with_params(2)
func_with_params(1)
func_with_params(7)
'''в консоли
[3]
[2]
[1]
[7] '''

'''Параметры по умолчанию внутри функции
На этом уроке вновь поговорим о функциях. Но мы рассмотрим некоторые дополнительные возможности.

Например, представим такую ситуацию. Мы пишем большую программу. У нас есть какая-то функция, 
но, пробегаясь по коду программы, видим, что каждый вызов функции имеет один и тот же результат.
 Также, допустим, функция принимающая, и в эту принимающую функцию в момент вызова мы передаём
  одни и те же значения. Например, функция, которая выводит нам сумму переданных в неё параметров(a+b). 
  Где-то в программе мы её вызываем и видим, что такой вызов встречается несколько раз. 
  То есть при запуске видим один и тот же результат(рис.1). Для таких случаев есть возможность задавать 
  параметры по умолчанию, то есть значения, которые будут храниться внутри этих параметров, если мы ничего 
  в неё не передадим.
Давайте проверим. Чтобы задать значение по умолчанию, нам нужно в голове функции при определении, 
после имени параметра поставить оператор присвоения, то есть знак равно и указать значение,
 которое этот параметр будет принимать по умолчанию. Сделаем, что “а=2” и “b=2”, соответственно нам это 
 даёт возможность вызывать функцию, при этом не передавая в неё никаких значений.
Запускаем и здесь видим 4, 4, 4, 4, то есть мы получили тот же самый результат.
При этом мы ничего в эту функцию не передавали.
Но если мы передадим сюда свои значения и запустим, то функция уже будет работать не с теми значениями,
 которые были определены изначально, а с теми, которые в момент вызова мы ей передали
Это достаточно удобно, но есть ряд важных моментов, о которых нужно помнить:
Значение параметров по умолчанию указываются только для конечных параметров. Что это значит? Если посмотреть,
 у нас есть параметр “а” и параметр “b”, они оба имеют значение по умолчанию. Но если указать, что первый 
 параметр принимает значение по умолчанию, а второй - нет, мы получим ошибку: 
 non-default argument follows default argument(рис.4), то есть аргумент без первоначального значения идёт
  за аргументом со значением по умолчанию.
То есть, если переставить, что “а” не имеет знания по умолчанию, а “b” имеет, тогда всё сработает 
как нужно. Только тут, раз у нас “а” не имеет значения по умолчанию, соответственно, вызовы функции
 мы должны это “а” передать. Запускаем, видим результат 5, 5, 5, 5(рис.5), то есть первое значение 
 передали, а второе подставилось по умолчанию.
Но это не мешает точно также переопределять и второе значение и получать интересующий результат
 Здесь задумка в том, что мы по умолчанию указываем конечные параметры, те, которые имеют значение
  по умолчанию, всегда идут после тех, у которых значение по умолчанию отсутствует.
  
Соответственно, если бы здесь параметров было больше, то это работало бы таким образом: 
идёт параметр по умолчанию, параметр по умолчанию, здесь нет параметра по умолчанию. Ошибок никаких нет.
 Запускаем, видим результат. Мы передали всего два значения: “а” обязательно, потому что у него никакого
  значения нет, а “b” переопределили по умолчанию. Ответ: 3 + 5 + 3 = 11(рис.7). Всё верно, работает.
Когда мы работаем с параметрами по умолчанию, в качестве этих параметров мы указываем неизменяемые объекты. 
Нужно помнить, что эти значения параметров создаются не в момент, когда мы вызываем функцию, а создаются
 при её определении. Если мы в качестве какого-то изменяемого параметра, точнее в качестве параметра по
  умолчанию, укажем, например, список, то есть изменяемый объект. Давайте немного изменим функцию:
   она, например, в этот объект “с”, то есть в наш список будет добавлять параметр “а” и выводить этот список. 
   Получается "а” обязательно должны передать. Если запустим, то увидим, что эти значения,
    которые мы передаем, добавляются не в новый список, а в уже существующий. 
    Этот список был создан в момент определения функции func_with_params, и каждый вызов просто добавляем, 
    в уже существующий список, новый элемент.
Если нам необходимо избежать такого, например, работать в моменте, мы можем в “с” указать значение
 по умолчанию “None” и в функции проверить, что если “с”- “None”, тогда мы говорим, что “с” будет списком,
  и в этот список добавим “а”, потом выведем этот список(рис.9). Запускаем. В таких случаях у нас 
  список “с” будет переопределяться. Если мы будем менять объекты, результат тоже будет, соответственно
   разным
Подведём краткий итог.
У нас функция имеет возможность принимать параметры по умолчанию, что позволяет нам в момент вызова не 
передавать никаких аргументов. Но, если мы работаем с параметрами по умолчанию, 
мы их задаём либо конечным элементам, либо уж всем, которые присутствуют у нас в функции.
 И в качестве этих самых значений по умолчанию мы используем неизменяемые объекты.'''